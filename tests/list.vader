Include: include/setup.vader

Execute (List: basic: loclist):
  new
  normal! oline2
  normal! gg0
  let maker = {}
  function! maker.get_list_entries(...)
    let b = bufnr('%')
    return [
    \ {'text': '1', 'lnum': 1, 'bufnr': b},
    \ {'text': '2', 'lnum': 2, 'col': 3, 'bufnr': b},
    \ ]
  endfunction
  CallNeomake 1, [maker]
  AssertNeomakeMessage 'Adding 2 list entries.', 3

  AssertEqual getpos('.'), [0, 1, 1, 0]
  NeomakeNextLoclist
  AssertEqual getpos('.'), [0, 2, 3, 0]
  NeomakePrevLoclist
  AssertEqual getpos('.'), [0, 1, 1, 0]
  AssertNeomakeMessageAbsent 'Creating new List object.'
  bwipe!

Execute (List: basic: quickfix):
  new
  normal! oline2
  normal! gg0
  let maker = {}
  function! maker.get_list_entries(...)
    let b = bufnr('%')
    return [
    \ {'text': '1', 'lnum': 1, 'bufnr': b},
    \ {'text': '2', 'lnum': 2, 'col': 3, 'bufnr': b},
    \ ]
  endfunction
  CallNeomake 0, [maker]

  AssertEqual getpos('.'), [0, 1, 1, 0]
  NeomakeNextQuickfix
  AssertEqual getpos('.'), [0, 2, 3, 0]
  NeomakePrevQuickfix
  AssertEqual getpos('.'), [0, 1, 1, 0]
  AssertNeomakeMessageAbsent 'Creating new List object.'
  bwipe!

Execute (Sorting by location):
  let list = neomake#list#List('loclist')
  AssertEqual list.sort_by_location(), []

  let input = [
  \ {'lnum': 1, 'col': 2, 'bufnr': 1, 'type': ''},
  \ {'lnum': 1, 'col': 5, 'bufnr': 2, 'type': ''},
  \ {'lnum': 2, 'col': 1, 'bufnr': 1, 'type': ''},
  \ {'lnum': 3, 'col': 5, 'bufnr': 1, 'type': ''},
  \ {'lnum': 1, 'col': 2, 'bufnr': 1, 'type': 'E'},
  \ ]
  call list.add_entries(input)

  AssertEqual list.sort_by_location(), [
  \ {'lnum': 1, 'col': 2, 'bufnr': 1, 'type': 'E'},
  \ {'lnum': 1, 'col': 2, 'bufnr': 1, 'type': ''},
  \ {'lnum': 2, 'col': 1, 'bufnr': 1, 'type': ''},
  \ {'lnum': 3, 'col': 5, 'bufnr': 1, 'type': ''},
  \ {'lnum': 1, 'col': 5, 'bufnr': 2, 'type': ''},
  \ ]
  AssertEqual input[-1].lnum, 1, 'does not sort list in-place'

  " Sorts newly added entries.
  call list.add_entries([
  \ {'lnum': 1, 'col': 1, 'bufnr': 1, 'type': 'W'},
  \ ])
  AssertEqual list._sorted_entries_by_location, [
  \ {'lnum': 1, 'col': 1, 'bufnr': 1, 'type': 'W'},
  \ {'lnum': 1, 'col': 2, 'bufnr': 1, 'type': 'E'},
  \ {'lnum': 1, 'col': 2, 'bufnr': 1, 'type': ''},
  \ {'lnum': 2, 'col': 1, 'bufnr': 1, 'type': ''},
  \ {'lnum': 3, 'col': 5, 'bufnr': 1, 'type': ''},
  \ {'lnum': 1, 'col': 5, 'bufnr': 2, 'type': ''},
  \ ]

Execute (list: error with duplicate nmqfidx (debug=1)):
  let list = neomake#list#List('loclist')
  AssertEqual list.debug, 1
  call list.add_entries([
  \ {'lnum': 1, 'col': 1, 'bufnr': 1, 'type': 'W'},
  \ ])
  let list.entries[0].nmqfidx = 2
  call list.add_entries([
  \ {'lnum': 1, 'col': 1, 'bufnr': 1, 'type': 'W'},
  \ ])
  AssertNeomakeMessage 'Duplicate qf indexes in list entries: [2, 2].', 0

Execute (list: no error with duplicate nmqfidx (debug=0)):
  let list = neomake#list#List('loclist')
  let list.debug = 0
  call list.add_entries([
  \ {'lnum': 1, 'col': 1, 'bufnr': 1, 'type': 'W'},
  \ ])
  let list.entries[0].nmqfidx = 2
  call list.add_entries([
  \ {'lnum': 1, 'col': 1, 'bufnr': 1, 'type': 'W'},
  \ ])

Execute (quickfix list: gets local and sorts):
  Save g:_neomake_info
  unlet g:_neomake_info

  let list = neomake#list#List('quickfix')
  AssertEqual list.sort_by_location(), []

  call setqflist([
  \ {'lnum': 1, 'col': 2, 'bufnr': 1},
  \ {'lnum': 1, 'col': 5, 'bufnr': 1},
  \ {'lnum': 2, 'col': 1, 'bufnr': 1},
  \ {'lnum': 3, 'col': 5, 'bufnr': 1},
  \ {'lnum': 1, 'col': 1, 'bufnr': 1},
  \ ])

  let list = neomake#list#get_qflist()
  AssertEqual map(list.sort_by_location(), '[v:val.lnum, v:val.col, v:val.bufnr]'), [
  \ [1, 1, 1],
  \ [1, 2, 1],
  \ [1, 5, 1],
  \ [2, 1, 1],
  \ [3, 5, 1],
  \ ]

Execute (neomake#list#next):
  new
  let bufnr = bufnr('%')
  normal! iline1
  normal! oline2
  normal! oline3
  normal! gg^

  call setloclist(0, [
  \ {'lnum': 1, 'col': 1, 'bufnr': bufnr, 'text': 'idx1'},
  \ {'lnum': 1, 'col': 5, 'bufnr': bufnr, 'text': 'idx2'},
  \ {'lnum': 2, 'col': 1, 'bufnr': bufnr, 'text': 'idx3'},
  \ {'lnum': 3, 'col': 5, 'bufnr': bufnr, 'text': 'idx4'},
  \ {'lnum': 1, 'col': 2, 'bufnr': bufnr, 'text': 'idx5'},
  \ ])
  AssertEqual map(getloclist(0), '[v:val.lnum, v:val.text]'),
  \ [[1, 'idx1'], [1, 'idx2'], [2, 'idx3'], [3, 'idx4'], [1, 'idx5']],
  \ 'Sane lnums'

  Assert !exists('w:_neomake_info.loclist')

  AssertEqual getpos('.'), [0, 1, 1, 0]
  NeomakeNextLoclist
  AssertEqual getpos('.'), [0, 1, 2, 0]

  NeomakePrevLoclist
  AssertEqual getpos('.'), [0, 1, 1, 0]
  NeomakePrevLoclist
  AssertNeomakeMessage 'No more previous items.'

  3NeomakeNextLoclist
  AssertEqual getpos('.'), [0, 2, 1, 0]

  " Goes to last entry, without error message (like with :lnext).
  99NeomakeNextLoclist
  AssertEqual getpos('.'), [0, 3, 5, 0]

  " Error message when at last entry already (like with :lnext).
  99NeomakeNextLoclist
  AssertEqual getpos('.'), [0, 3, 5, 0]
  AssertNeomakeMessage 'No more next items.'

  " count=0 gets handles as 1.
  0NeomakePrevLoclist
  AssertEqual getpos('.'), [0, 2, 1, 0]
  0NeomakeNextLoclist
  AssertEqual getpos('.'), [0, 3, 5, 0]
  bwipe!

Execute (neomake#list#_diff_new_entries):
  AssertEqual neomake#list#_diff_new_entries([], []), {}
  AssertEqual neomake#list#_diff_new_entries([{}], [{'valid': 0}]), {'0': {'changed': {'valid': [1, 0]}}}
  AssertEqual neomake#list#_diff_new_entries([{}, {}], [{}, {'valid': 0}]), {'1': {'changed': {'valid': [1, 0]}}}

  " Handles different lengths.
  AssertEqual neomake#list#_diff_new_entries([{}], []), {}
  AssertEqual neomake#list#_diff_new_entries([], [{}]), {}

  AssertEqual neomake#list#_diff_new_entries([{'length': 1}], [{}]), {}

  AssertEqual neomake#list#_diff_new_entries([{'text': 'error'}], [{'text': 'error', 'valid': 1, 'pattern': ''}]),
  \ {}

Execute (Does not create list unnecessarily):
  if !has('patch-8.0.1040')  " 'efm' in setqflist/getqflist
    NeomakeTestsSkip 'only with efm parsing'
  else
    new
    lgetexpr 'init'
    let list = neomake#list#ListForMake({'options': {'file_mode': 1}})
    let jobinfo = NeomakeTestsFakeJobinfo()
    let jobinfo.maker.errorformat = '%m'
    call list.add_lines_with_efm([], jobinfo)
    AssertEqual map(getloclist(0), 'v:val.text'), ['init']
    bwipe
  endif

Execute (list: error handling):
  new
  let list = neomake#list#List('loclist')

  let threw = 0
  try
    call list._get_loclist_win()
  catch
    AssertEqual v:exception, 'cannot handle type=loclist without make_info'
    let threw = 1
  endtry
  AssertEqual threw, 1

  " Invalid location list qfid (loclist).
  let jobinfo = NeomakeTestsFakeJobinfo()
  let list.make_info = neomake#GetStatus().make_info[-42]

  let threw = 0
  try
    call list._get_fn_args('init', [])
  catch
    let threw = 1
    AssertEqual v:exception, 'Neomake: could not find location list for make_id -42.'
  endtry
  if exists('*win_getid')
    AssertEqual threw, 0
  else
    " location list from another tab"
    tabnew
    let w:neomake_make_ids = [-42]
    tabprev
    let threw = 0
    try
      call list._get_fn_args('get')
    catch
      let threw = 1
      AssertEqual v:exception, 'Neomake: trying to use location list from another tab (current=3 != target=4).'
    endtry
    AssertEqual threw, 1
    tabnext
    bwipe

    new
    let w:neomake_make_ids = [-42]
    call list._get_fn_args('init', [])
    wincmd p
  endif
  Assert !has_key(list, 'qfid')
  call list._init_qflist()
  call list._get_fn_args('get')

  if has('patch-8.0.1023')
    let list.qfid = list.qfid + 1

    Assert !list._has_valid_qf()

    let threw = 0
    try
      call list._get_fn_args('get')
    catch
      let threw = 1
      let win_id = exists('*win_getid') ? win_getid() : winnr()
      AssertEqual v:exception, printf('Neomake: qfid %d for location list (%d) has become invalid.', list.qfid, win_id)
    endtry
    AssertEqual threw, 1

    " Invalid location list qfid (qflist).
    let list.type = 'quickfix'

    let threw = 0
    try
      call list._get_fn_args('get')
    catch
      let threw = 1
      AssertEqual v:exception, printf('Neomake: qfid %d for quickfix list has become invalid.', list.qfid)
    endtry
    AssertEqual threw, 1
  endif

  if !exists('*win_getid')
    wincmd p
    bwipe
  endif
  bwipe

Execute (list: add_lines_with_efm uses own list):
  new

  let jobinfo = NeomakeTestsFakeJobinfo()
  let jobinfo.maker.errorformat = '%m'
  let make_info = neomake#GetStatus().make_info[-42]
  let w:neomake_make_ids = [-42]

  let list = neomake#list#ListForMake(make_info)
  call list.add_lines_with_efm(['error1'], jobinfo)

  AssertEqual map(getloclist(0), 'v:val.text'), ['error1']

  " Create new location list.
  lgetexpr 'new_list'

  call list.add_lines_with_efm(['error2'], jobinfo)

  if has('patch-8.0.1040')
    AssertEqual map(getloclist(0), 'v:val.text'), ['new_list']
    lolder
    AssertEqual map(getloclist(0), 'v:val.text'), ['error1', 'error2']
  else
    " TODO: check/fix this via nmcfg marker."
    AssertEqual map(getloclist(0), 'v:val.text'), ['new_list', 'error2']
    lolder
    AssertEqual map(getloclist(0), 'v:val.text'), ['error1']
  endif
  bwipe

Execute (list: title):
  new
  let job1 = NeomakeTestsFakeJobinfo()
  let job1.maker.name = 'job1'

  let make_info = neomake#GetStatus().make_info[-42]
  let w:neomake_make_ids = [-42]

  let list = neomake#list#ListForMake(make_info)

  let prefix = 'Neomake[file]: buf:'.bufnr('%')
  AssertEqual list._get_title(), prefix.' (job1?)'

  let job2 = NeomakeTestsFakeJobinfo()
  let job2.maker.name = 'job2'
  let list.make_info.active_jobs = [job2]
  AssertEqual list._get_title(), prefix.' (job2..., job1?)'

  " Finished jobs with no entries are not displayed."
  let job3 = NeomakeTestsFakeJobinfo()
  let job3.maker.name = 'job3'
  let list.make_info.finished_jobs = [job3]
  AssertEqual list._get_title(), prefix.' (job2..., job1?)'

  call list.add_entries_for_job([{'text': 'e2', 'bufnr': bufnr('%')}], job2)
  AssertEqual list._get_title(), prefix.' (job2...(1), job1?)'

  call list.add_entries_for_job([{'text': 'e3', 'bufnr': bufnr('%')}], job3)
  AssertEqual list._get_title(), prefix.' (job3(1), job2...(1), job1?)'
  bwipe

Execute (list: reset):
  new
  let jobinfo = NeomakeTestsFakeJobinfo()
  let jobinfo.maker.errorformat = '%m'
  let make_info = neomake#GetStatus().make_info[-42]
  let w:neomake_make_ids = [-42]

  let list = neomake#list#ListForMake(make_info)
  call list._init_qflist()
  call list.add_entries([
  \ {'lnum': 1, 'col': 1, 'bufnr': 1, 'type': 'W'},
  \ ])
  call list.reset_qflist()
  AssertEqual list.entries, []
  AssertEqual list.job_entries, {}
  bwipe
